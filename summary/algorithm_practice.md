# 算法基础应用

## 基础知识

```shell
    1. 跟排序有关的有序度和逆序度
            (1) 有序度是数组中有序关系的元素对的个数，
                    即　a[i] <= a[j], 如果 i < j。(默认从小到大为有序)
                    例如：　2, 4, 3, 1, 这组数据有序度为 2
                           (2, 4), (2, 3) 
                           
                    对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；
                    
                    对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是n*(n-1)/2，也就是 15。
                    这种完全有序的数组的有序度叫作满有序度。
                    
            (2) 逆序度的定义正好跟有序度相反,即　a[i] <= a[j], 如果 j < i (默认从小到大为有序)
            (3) 逆序度 = 满有序度 - 有序度。排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，说明排序完成
                例如:
                    排序的数组的初始状态是 4，5，6，3，2，1 有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。
                    n=6，所以排序完成之后终态的满有序度为 n*(n-1)/2=15。

```

## 递归

```shell
    1. 知识点
            (1) 所有的递归问题都可以用递推公式来表示,有递推公式，可以很轻松地将它改为递归代码
    2. 递归需要满足的三个条件
            (1) 第一个条件: 一个问题的解可以分解为几个子问题的解
            (2) 第二个条件: 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
            (3) 第三个条件: 存在递归终止条件
    3. 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，
    　　最后将递推公式和终止条件翻译成代码
    4. 对于递归代码，试图想清楚整个递和归过程的做法，实际上是进入一个思维误区.如果一个问题 A 可以分解为若干子问题 B、C、D，
      可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，
      不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多。
      编写递归代码的关键是，只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。
    5. 注意
            (1) 递归代码要警惕堆栈溢出,因为每调用一次函数，系统就会将函数内的局部变量压入栈内，如果递归求解的数据规模很大，
            　　调用层次很深，一直压入栈，就会有堆栈溢出的风险。
            　　解决方案: 
                    在代码中限制递归调用的最大深度的方式。递归调用超过一定深度（比如 1000）之后，不再继续往下递归，直接返回报错
            (2) 避免重复计算以提高性能
                    例如 f(6) = f(5) + f(4), f(5) = f(4) + f(3)  这里根据递归 f(4) 会被计算两次，可以通过散列表
                    来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，
                    不需要重复计算．
```

## 二分查找(Binary Search)

```
    1. 二分查找也称为折半查找，二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，
    　　将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。
    2. 二分查找的时间复杂度 O(logn)
            刚开始数据量为 n, 经过一次二分查找后为 n / 2, 第二次二分查找有数据量为 n / 4, 所以当找到对应的数据时需要 k 次
             n/(2 ^ k) = 1 , k = logn,所以时间复杂度就是 O(logn)
    3. 二分查找的局限性
            (1) 二分查找依赖的是顺序表结构(数组)
                    二分查找需要具备按照下标进行随机访问，链表很难实现
            (2) 二分查找针对的是有序数据
                    二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用,因为
                    每一次的插入，删除都要进行先排序后二分查找，其维护有序的成本高，像这种动态数据集合中快速的查找可以用二叉树.
            (3) 二分查找的数据量不宜过大和过小．
                    因为它的存储是顺序存储，所以过大则需内存中连续的大空间，如果过小则使用遍历也是同样的效果
                    
    4. 应用
            (1) 用内存 100MB 快速查找 1000 万个整数,每个数据大小是 8 字节．用二分查找，先用数据进行数据保存而进行排序，之后再进行
            　　　二分查找．　在这种情况下(内存受限)，不宜使用二叉树和散列表，因为这 2 中数据结构需要额外的内存
            
    5. 二分查找变形问题
            (1) 变形一: 查找第一个等于给定值的元素
                        　即在有序数据集合中存在重复的数据，找到第一个等于给定值的元素
                        
                        实现代码:
                                public int bsearch(int[] a, int n, int value) {
                                  int low = 0;
                                  int high = n - 1;
                                  while (low <= high) {
                                    int mid =  low + ((high - low) >> 1);
                                    if (a[mid] > value) {
                                      high = mid - 1;
                                    } else if (a[mid] < value) {
                                      low = mid + 1;
                                    } else {  // 当取到的值等于给定的值时，需要考虑是否为第一个值
                                      if ((mid == 0) || (a[mid - 1] != value)) return mid;
                                      else high = mid - 1;
                                    }
                                  }
                                  return -1;
                                }
                                
            (2) 变形二:查找最后一个值等于给定值的元素
                        实现代码:
                                public int bsearch(int[] a, int n, int value) {
                                  int low = 0;
                                  int high = n - 1;
                                  while (low <= high) {
                                    int mid =  low + ((high - low) >> 1);
                                    if (a[mid] > value) {
                                      high = mid - 1;
                                    } else if (a[mid] < value) {
                                      low = mid + 1;
                                    } else {  // 当取到的值等于给定的值时，需要考虑是否为最后一个值
                                      if ((mid == n - 1) || (a[mid + 1] != value)) return mid;
                                      else low = mid + 1;
                                    }
                                  }
                                  return -1;
                                }
                                
            (3) 变形三：查找第一个大于等于给定值的元素
                        实现代码:
                                public int bsearch(int[] a, int n, int value) {
                                  int low = 0;
                                  int high = n - 1;
                                  while (low <= high) {
                                    int mid =  low + q   ((high - low) >> 1);
                                    if (a[mid] < value) {
                                      low = mid + 1;
                                    } else {  // 当取值满足条件(即大于等于给定值)，那么还需要判断是否是第一个大于等于给定值的元素
                                      if ((mid == 0) || (a[mid - 1] < value)) return mid;
                                      else high = mid - 1;
                                    }
                                  }
                                  return -1;
                                }    
                                               
            (4) 变形四：查找最后一个小于等于给定值的元素
                         实现代码:
                                 public int bsearch(int[] a, int n, int value) {
                                   int low = 0;
                                   int high = n - 1;
                                   while (low <= high) {
                                     int mid =  low + q   ((high - low) >> 1);
                                     if (a[mid] > value) {
                                       high = mid - 1;
                                     } else {  // 当取值满足条件(即大于等于给定值)，那么还需要判断是否是第一个大于等于给定值的元素
                                       if ((mid == n - 1) || (a[mid + 1] > value)) return mid;
                                       else low = mid + 1;
                                     }
                                   }
                                   return -1;
                                 }             
                                                      
            (5) 变形的应用:
                    假设我们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地呢？
                    思路如下: 先预处理这 12 万条数据，将 IP 范围的中取开始 IP 从小到大排序(结束 IP 不管),而 IP 地址(字符串)
                    　　　　　可以转化为 32 位的整型数(struct  in_addr)
                             这样这个问题就可以转化为第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素”了。
                             当我们要查询某个 IP 归属地时，我们可以先通过二分查找，找到最后一个起始 IP 小于等于这个 IP 的 IP 区间，
                             然后，检查这个 IP 是否在这个 IP 区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。
```