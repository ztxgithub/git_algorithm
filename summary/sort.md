# 排序

```shell
    1. 分析排序算法
            (1) 排序算法的执行效率
                    a. 最好情况、最坏情况、平均情况时间复杂度. 知道这些情况对应的初始数据
                    b. 时间复杂度的系数、常数 、低阶, 在对同一阶时间复杂度的排序算法性能对比时，
                    　　要把系数、常数、低阶也考虑进来
                    c. 比较次数和交换（或移动）次数
            (2) 排序算法的内存消耗, 原地排序(Sorted in place):特指空间复杂度是 O(1) 的排序算法,
                冒泡排序，插入排序，选择排序都是原地排序．
            (3) 排序算法的稳定性
                    稳定性:如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变为稳定．
                    例如:
                        一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。
                        这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，则为稳定的排序算法
                        
                    稳定排序作用：
                        在现实软件开发中，排序的往往不是单纯的整数，而是一组对象，需要按照对象的某个 key 来排序。而有的时候
                        需要在某个 key1 排序基础上，再按照 key2 进行排序，用稳定排序可以减少代码的复杂度．
                        
                        例如: 电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。
                              按照金额从小到大对订单数据排序,对于金额相同的订单，按照下单时间从早到晚有序
                              
                              代码复杂度高的思路:
                                    先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，
                                    对于每个金额相同的小区间再按照下单时间排序
                                    
                              代码复杂度低的思路:
                                    先按照下单时间给订单排序，排序完成之后，我们用稳定排序算法，按照订单金额重新排序。
                                    两遍排序之后，得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的
```

## 时间复杂度为 O(n ^ 2) 的排序算法

```shell
    1. 冒泡排序(Bubble Sort)
            (1) 思路: 冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。
                      如果不满足就让它俩互换。 一次冒泡会让至少一个元素移动到它应该在的位置(不一定是数组的第一个元素)，重复 n 次，
                      就完成了 n 个数据的排序工作。 当冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作．
            
            (2) 实例代码:
                        // 冒泡升序排序，a 表示数组，n 表示数组大小
                        public void bubbleSort(int[] a, int n) 
                        {
                          if (n <= 1) return;
                         
                             for (int i = 0; i < n; ++i) {
                                // 提前退出冒泡循环的标志位
                                boolean flag = false;
                                // 这里 j 的值是因为每次排序都会每次最大值排在最后，所以没必要在对后面的值进行比较
                                for (int j = 0; j < n - i - 1; ++j) {　
                                  if (a[j] > a[j+1]) { // 交换
                                    int tmp = a[j];
                                    a[j] = a[j+1];
                                    a[j+1] = tmp;
                                    flag = true;  // 表示有数据交换      
                                  }
                                }
                                if (!flag) break;  // 没有数据交换，提前退出
                              }
                        }
                  
            (3) 由代码可知
                    a. 冒泡排序是稳定的排序算法,是原地排序算法
                    b. 时间复杂度：
                            1. 最好情况时间复杂度 O(n), 要排序的数据已经是有序，只需要进行一次冒泡操作，就可以结束
                            2. 最坏情况时间复杂度为 O(n ^ 2), 要排序的数据是倒序，需要进行 n 次冒泡操作
                            3. 平均情况下的时间复杂度就是 O(n ^ 2)
                                冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1。
                                交换次数总是确定的(逆序度)，也就是n*(n-1)/2 - 初始有序度.
                                
                                最坏情况下，初始状态的有序度是 0，进行 n*(n-1)/2 次交换。
                                最好情况下，初始状态的有序度是 n*(n-1)/2，就不需要进行交换。
                                可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。
                                平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n ^ 2)，
                                所以平均情况下的时间复杂度就是 O(n ^ 2)。
                                
    2. 插入排序(Insertion Sort)
            (1) 思路: 数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。
                      取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入(插入后面的元素需要整体后移一位)，
                      并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。
                      
                       4213 -> 2413 -> 1243 -> 1234
                       
            (2) 对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。
                但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度(满序度 - 有序度)
                
            (3) 代码:
                    // 插入排序(升序)，a 表示数组，n 表示数组大小
                    public void insertionSort(int[] a, int n) {
                      if (n <= 1) return;
                     
                      for (int i = 1; i < n; ++i) {
                        int value = a[i];
                        int j = i - 1;
                        // 查找插入的位置, 从后往前比较
                        for (; j >= 0; --j) {
                          if (a[j] > value) {
                            a[j+1] = a[j];  // 数据移动
                          } else {
                            break;
                          }
                        }
                        a[j+1] = value; // 插入数据
                      }
                    }
                    
            (4) 由代码可知:
                    a. 插入排序是原地排序算法，同时是稳定的排序算法
                    b. 时间复杂度：
                            最好情况时间复杂度 O(n)： 不考虑以上的代码，从尾到头在有序数据组里面查找插入位置，
                                                    只需要一次遍历就能结束。最好是时间复杂度为 O(n)。
                            最坏情况时间复杂度为 O(n ^ 2) : 数组是倒序
                            平均时间复杂度为 O(n ^ 2):在数组中插入一个数据的平均时间复杂度是是 O(n)。
                                                    对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，
                                                    循环执行 n 次插入操作
                                                    
    3. 选择排序(Selection Sort)
            (1) 思路: 选择排序也分已排序区间和未排序区间。选择排序每次会从未排序区间中找到最小的元素，
                      将其放到已排序区间的末尾。主要的代码实现是在未排序区间选出最小的值，通过最小的值与
                      未排序区间第一个元素交换，同时未排序区间减 1 ,未排序区间起始地址下移一位
                      
                      5914 -> 1954 -> 1459 -> 1459
                      
            (2) a. 选择排序是原地排序算法
                b. 选择排序是不稳定的排序算法，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。
                     比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，
                     那第一个 5 和中间的 5 顺序就变了，所以就不稳定
                c. 时间复杂度：
                           最好情况时间复杂度 O(n ^ 2)： 不管是否有序，都会依次对无序区间筛选出最小值放到有序区间的末尾
                           最坏情况时间复杂度为 O(n ^ 2) 
                           平均时间复杂度为 O(n ^ 2)
                           
    4. 冒泡排序与插入排序比较
            (1) 由上面的代码比较知道，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，
            　　而插入排序只需要 1 个．把执行一个赋值语句的时间粗略地计为单位时间（unit_time），
            　　然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，
            　　所以交换操作总耗时就是 3 * K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。
            
    5. 总结
            对于小规模数据的排序，冒泡排序，插入排序，选择排序用起来非常高效。但是在大规模数据排序的时候，
            更倾向于时间复杂度为 O(nlogn) 的排序算法。
            
```

## 时间复杂度为 O(n * logn) 的排序算法

```shell
    1. 归并排序和快速排序都用到了分治思想,分治就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。
       分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突
    2. 归并排序(merge sort)
            (1) 核心思想: 如果要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，
                         这样整个数组就都有序了.
            (2) 归并排序用的是分治思想，可以用递归来实现
            (3) merge(A[p…r], A[p…q], A[q+1…r]), 此时 A[p…q] 和 A[q+1…r] 已经是排好序的数组了，如何将这两个数组整合到
            　　A[p…r] 中，方案如下:
            　　申请一个临时数组 tmp，大小与 A[p…r] 相同。用两个游标 i 和 j，分别指向 A[p…q] 和 A[q+1…r] 的第一个元素。
               比较这两个元素 A[i] 和 A[j]，如果 A[i]<=A[j]，我们就把 A[i] 放入到临时数组 tmp，并且 i 后移一位，
               否则将 A[j] 放入到数组 tmp，j 后移一位。 继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，
               再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。
               最后再把临时数组 tmp 中的数据拷贝到原数组 A[p…r] 中。
            (4) 相关代码:
            
                    // 归并排序算法, A 是数组，n 表示数组大小
                    merge_sort(A, n) {
                      merge_sort_c(A, 0, n-1)
                    }
                     
                    // 递归调用函数
                    merge_sort_c(A, p, r) {
                      // 递归终止条件
                      if p >= r  then return
                     
                      // 取 p 到 r 之间的中间位置 q
                      q = (p+r) / 2
                      // 分治递归
                      merge_sort_c(A, p, q)
                      merge_sort_c(A, q+1, r)
                      // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]
                      merge(A[p...r], A[p...q], A[q+1...r])
                    }
            (5) 归并排序的性能分析
                    A. 归并排序是一个稳定的排序算法，归并排序稳不稳定关键要看 merge() 函数，两个有序子数组合并成一个有序数组的那部分代码。
                       在合并的过程中，如果 A[p…q] 和 A[q+1…r] 之间有值相同的元素，先把 A[p…q] 中的元素放入 tmp 数组。这样保证
                       值相同的元素，在合并前后的先后顺序不变
                    B. 最好情况复杂度，最坏情况复杂度，平均复杂度都为 O(nlogn)
                            递归公式的时间复杂度： T(a) = T(b) + T(c) + K,  
                            　　　　　　　　　　　 K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间.
                            不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。
                            对 n 个元素进行归并排序需要的时间是 T(n)，分解成两个子数组排序的时间都是 T(n/2)
                            merge() 函数合并两个有序子数组的时间复杂度是 O(n)。套用前面的公式对于归并排序时间复杂度:
                                T(1) = C, 
                                T(n) = 2 * T(n / 2) + n
                                     = 2 * T(n / 2) + n
                                     = 2 ^2 *T(n/ 2 ^ 2) + 2 * n
                                     = 2 ^3 *T(n/ 2 ^ 3) + 3 * n
                                     = 2 ^ k * T(n/ 2 ^ k) + k * n
                                     
                                所以:
                                    n/ 2 ^ k = 1 得出: k = log2 n
                                T(n) = n * C + n * log2 n, 所以　T(n) 就等于 O(nlogn)
                    C. 归并排序不是原地排序算法,需要申请额外的空间保存合并后的数据, 空间复杂度为 O(n),
                       尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，
                       CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小
                       
    3. 快速排序(Quicksort)
            (1) 快排的思想：下标从 p 到 r 之间的一组数据，选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。
                          遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，
                          经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，
                          中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。再根据分治、递归的处理思想，
                          用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序
                          
            (2) 伪代码实现:
                    // 快速排序，A 是数组，n 表示数组的大小
                    quick_sort(A, n) {
                      quick_sort_c(A, 0, n-1)
                    }
                    // 快速排序递归函数，p,r 为下标
                    quick_sort_c(A, p, r) {
                      if p >= r then return
                      
                      q = partition(A, p, r) // 获取分区点, 同时将 A 数组进行初步的排序操作, q 的左边都是小于 A[q], 右边都是大于 A[q]
                      quick_sort_c(A, p, q-1)
                      quick_sort_c(A, q+1, r)
                    }
                    
                    partition() 分区函数是随机选择一个元素作为 pivot（一般情况下，可以选择 p 到 r 区间的最后一个元素），
                    然后对 A[p…r] 分区，函数返回 pivot 的下标(进行初步排序后的下标)
                    
                    partition(A, p, r) 
                    {
                      pivot := A[r]
                      i := p
                      for j := p to r-1 do {
                        if A[j] < pivot {  // 当检索到该下标的值小于 pivot 的值, 将 A[i] 与 A[j] 交换　
                          swap A[i] with A[j]
                          i := i+1
                        }
                      }
                      swap A[i] with A[r]  // 此时将 A[i] 与　pivot　进行交换
                      return i
                    }
                   处理有点类似选择排序。通过游标 i 把 A[p…r-1] 分成两部分。A[p…i-1] 的元素都是小于 pivot 的，是“已处理区间”，
                   A[i…r-1] 是“未处理区间”。每次遍历未处理的区间 A[i…r-1] 中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，
                   则将其加入到已处理区间的尾部，也就是 A[i] 的位置。
            (3) 快排的性能分析
                    A. 快排是原地排序，不稳定的排序算法．因为在 partition() 分区函数存在数据交换，导致相同的值顺序会发送变化．
                    B. 最好情况时间复杂度为 O(nlogn), 如果在某一很好的顺序下，每次选择的 partition 都能将区间对半分， 
                                               那快排的时间复杂度递推求解公式跟归并是相同的
                       最坏情况时间复杂度为 O(n ^ 2), 数据原来已经是有序了，比如 1，3，5，6，8，需要进行大约 n 次分区操作，
                       　　　　　　　　　　　　　　　　才能完成快排的整个过程。每次分区我们平均要扫描大约 n/2 个元素
                       平均时间复杂度为 O(nlogn)
                   
    4. 归并排序和快排
            (1) 归并排序的处理过程是由下到上的，先处理子问题(即排好序)，然后再合并。
            　　 而快排正好相反，它的处理过程是由上到下的，先分区(即排好序，大范围左边都小于 partition , 右边都大于 partition)，
                然后再处理子问题(再在各个大范围部分分区)
            (2) 归并排序虽然是稳定排序算法，但其合并函数要申请内存空间，会占用内存，而快排则是原地排序．
            
    5. 应用
            (1) 查找无序数组中的第 K 大元素， 如 4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4.
                解决的思路：通过分区的方法，先在A[0....r], 取最后 A[r] 作为分区点的值，第一遍先遍历使得
                　　　　　　左边部分是大于该分区点，如果 p(分区点) + 1= K，那 A[p] 就是要求解的元素；
                          如果 K > p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 
                          A[p+1…n-1] 这个区间内分区查找。
                          如果 K < p + 1，那我们就在 A[0…p-1] 区间查找。
```

## 时间复杂度为 O(n) 的排序算法(线性排序 Linear sort)

```shell
    1. 线性排序（Linear sort）:　其排序算法的时间复杂度为线性的O(n), 能够达到线性的时间复杂度是因为不是基于比较的排序算法，
    　　　　　　　　　　　　　　　都不涉及元素之间的比较操作,其排序算法对要排序的数据要求很苛刻．例如：桶排序，计数排序，计数排序等．
    
    2. 桶排序(Bucket sort)
            (1) 核心思想: 将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，
                         再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。
                         例如: 将　5,12,6,2,25,9 进行桶排序，结果是 桶1 里的内容是(2,5,6,9) , 桶 2 的内容(12), 桶 3 是(25)
            (2) 时间复杂度为 O(n)
                    要排序的数据有 n 个，把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，
                    时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，
                    所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，
                    这个时候桶排序的时间复杂度接近 O(n)
            (3) 桶排序的条件
                    A. 要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，
                       桶与桶之间的数据不需要再进行排序
                    B. 数据在各个桶之间的分布是比较均匀的。
                       如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，
                       那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，
                       那就退化为 O(nlogn) 的排序算法
                    C. 适用场景
                            适合用在外部排序中。外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中，
                            但要对这些外部磁盘的数据进行排序．
                            例如:
                                有 10GB 的订单数据，希望按订单金额（假设金额都是正整数）进行排序，但是内存有限，只有几百 MB，
                                没办法一次性把 10GB 的数据都加载到内存中.
                                采取的方法是：通过桶排序，
                                                1. 确定金额的范围，通过一次遍历
                                                2. 再根据金额范围确定桶的个数，那么一个桶内的金额范围就确定了，例如
                                                　　将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之
                                                　　　内的订单，第二桶存储金额在 1001 元到 2000 元之内的订单
                                                3. 在遍历一遍，根据金额放到对应的桶中．
                                                4. 在每一桶内进行快排操作(将桶文件读到内存中)，再将排序好的数据更新到磁盘中，
                                                　　这样所有的桶文件都是有序的．这些都是在理想情况下，数据都是均匀分布在每一个桶内．
                                                　　如果 10GB 订单数据是无法均匀地被划分到 100 个文件中的。有可能某个金额区间的
                                                    数据特别多，划分之后对应的文件就会很大，没法一次性读入内存.那么就需要对这文件
                                                    继续进行更细桶的划分．
                                                    
    3. 计数排序(Counting sort)
            (1) 计数排序是特殊的桶排序，其要求对应的桶值是相同的，所以计数排序只能用在数据范围不大的场景中，
                如果数据范围 k(最大值 - 最小值) 比要排序的数据 n(要排序的个数) 大很多，就不适合用计数排序。
            (2) 计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数
                例如: 如果考生成绩精确到小数后一位，将所有的分数都先乘以 10，转化成整数，然后再放到 9010 个桶内(满分为 900)。
                      如果要排序的数据中有负数，数据的范围是 [-1000, 1000]，需要先对每个数据都加 1000，转化成非负整数。
            (3) 过程:
                        A. 第一步，先定义一个数组 A(其下标代表要排序的值)，数组元素的值代表下标相同对应的个数.先遍历待排序的
                        　　　　　　序列，将数组 A 填充好
                        B. 第二步，将 数组 A 中顺序求和，即在第一步中 A[5] 的值等于前面 A[0] ~ A[5] 的总和
                        C. 第三步，申请数组 B (代表排序后的序列),遍历待排序的序列(排序必须从后往前，否则不是稳定排序,
                        　　　　　　因为后面的数据要放在数据后面，　A[index] 的大小是由大变小)，
                                  在数组 A 中通过值定位下标，将取A[index]的值，
                        　　　　　　再将该排序的值插入到 B 数组中(下标为 A[index]), 之后 A[index]--
            (4) 代码实现:
                        // 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。
                        public void countingSort(int[] a, int n) {
                          if (n <= 1) return;
                         
                          // 查找数组中数据的范围
                          int max = a[0];
                          for (int i = 1; i < n; ++i) {
                            if (max < a[i]) {
                              max = a[i];
                            }
                          }
                         
                          int[] c = new int[max + 1]; // 申请一个计数数组 c，下标大小 [0,max]
                          for (int i = 0; i <= max; ++i) {
                            c[i] = 0;
                          }
                         
                          // 计算每个元素的个数，放入 c 中
                          for (int i = 0; i < n; ++i) {
                            c[a[i]]++;
                          }
                         
                          // 依次累加
                          for (int i = 1; i <= max; ++i) {
                            c[i] = c[i-1] + c[i];
                          }
                         
                          // 临时数组 r，存储排序之后的结果
                          int[] r = new int[n];
                          // 计算排序的关键步骤，有点难理解，排序必须从后往前，否则不是稳定排序
                          for (int i = n - 1; i >= 0; --i) {
                            int index = c[a[i]]-1;
                            r[index] = a[i];
                            c[a[i]]--;
                          }
                         
                          // 将结果拷贝给 a 数组
                          for (int i = 0; i < n; ++i) {
                            a[i] = r[i];
                          }
                        }
                        
            (5) 应用
                    A. 50 万考生，如何通过成绩排序得出名次
                    B. 根据年龄给 100 万用户排序
                        
    4. 基数排序(Radix sort)
            (1) 基数排序可以用在值范围大的排序中，按位进行排序，固定位数不够补 0
            (2) 基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，
                 如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。
                 每一位的数据范围不能太大，可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n)
            (3) 基本思路:
                    A. 有低位(个位数)向前(百位，千位)进行遍历
                    B. 在每一位中再按照计数排序
                           /*计数*/
                            for (j = 0; j < size; j++)
                            {
                                index = NUM_OF_POS(a[j],pval);
                                count[index]++;
                            }
                             /*累加*/
                            for(j = 1; j < 10; j ++)
                            {
                                count[j] += count[j-1];
                            }
                           for(j = size -1; j >= 0; j--)
                            {
                                index = NUM_OF_POS(a[j],pval);
                                pres[count[index] - 1] = a[j];
                                count[index]--;
                            }
                            /*本轮排序好的，拷贝到a中*/
                            memcpy(a,pres,sizeof(int)*size);
                 
            (4) 应用
                    10 万个手机号码，希望将这 10 万个手机号码从小到大排序,借助稳定排序算法,先按照最后一位来排序手机号码，然后，
                    再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。
                
                        
```