# 二叉树

## 基础知识

```shell
    1.结点的高度 = 该结点到叶子结点的最长路劲(边数)
      结点的深度 = 根节点到到这个结点所经历的边的个数
      结点的层数 = 结点的深度 + 1
      树的高度 =  根结点的高度
      
    2. 满二叉树: 叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点
       完全二叉树: 叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大
    3. 前驱结点：节点 val 值小于该节点 val值 并且值最大的节点 
       后继节点：节点 val 值大于该节点 val 值并且值最小的节点
    
```

## 存储二叉树

```shell
    1. 链式存储法(常用,链表)
        每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针,只要拿到根结点就能遍历整个二叉树
    2. 顺序存储法(基于数组)
            把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。
            以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置
            
            如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的
            就是右子节点。 下标为 i/2 的位置存储就是它的父节点。只要知道根节点存储的位置(为了方便计算子节点，根节点会存储
            在下标为 1 的位置)，　就可以通过下标计算，把整棵树都串起来
            
            (1) 完全二叉树仅仅“浪费”了一个下标为 0 的存储位置。如果是非完全二叉树，会浪费比较多的数组存储空间
                如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式,
            (2) 数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。
            
```

## 遍历二叉树

```shell
    主要前，中，后是针对当前结点而言
    1. 前序遍历
            (1) 对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
            (2) 前序遍历的递推公式： preOrder(r) = print r -> preOrder(r->left) -> preOrder(r->right)
            (3) 代码:
                    void preOrder(Node* root) {
                      if (root == null) return;
                      print root // 此处为伪代码，表示打印 root 节点
                      preOrder(root->left);
                      preOrder(root->right);
                    }

    2. 中序遍历
            (1) 对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
            (2) 中序遍历的递推公式： inOrder(r) =  inOrder(r->left) ->  print r -> inOrder(r->right)
            (3) 代码:
                    void inOrder(Node* root) {
                      if (root == null) return;
                      inOrder(root->left);
                      print root // 此处为伪代码，表示打印 root 节点
                      inOrder(root->right);
                    }
    3. 后序遍历
            (1) 对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。
            (2) 后序遍历的递推公式: postOrder(r) = postOrder(r->left) -> postOrder(r->right) -> print r
            (3) 代码:
                    void postOrder(Node* root) {
                      if (root == null) return;
                      postOrder(root->left);
                      postOrder(root->right);
                      print root // 此处为伪代码，表示打印 root 节点
                    }
                    
    4. 层序遍历(广度优先遍历) : 借用队列辅助即可，根节点先入队列，然后循环从队列中pop节点，将pop出来的节点的左子节点先入队列，
                             右节点后入队列，依次循环，直到队列为空，遍历结束
                    
    5. 二叉树遍历的时间复杂度是 O(n), 每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比
    
```

## 二叉查找树(Binary Search Tree)

```shell
    1. 二叉查找树也叫二叉搜索树，二叉查找树是为了实现快速查找而生的
    2. 二叉查找树最大的特点就是，支持动态数据集合的快速插入、删除、查找操作，能够实现这些特性依赖于特殊结构，
       二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值
       二叉查找树也有可能极度不平衡(二叉查找树的高度为 n)
    3. 二叉树查找树的查找操作
            (1) 中心思想:
                        先取根节点，如果它等于要查找的数据，就返回。如果要查找的数据比根节点的值小，就在左子树中递归查找；
                        如果要查找的数据比根节点的值大，就在右子树中递归查找。
            (2) 代码实现:
                        public class BinarySearchTree {
                          private Node tree;
                         
                          public Node find(int data) {
                            Node p = tree;
                            while (p != null) {
                              if (data < p.data) p = p.left;
                              else if (data > p.data) p = p.right;
                              else return p;
                            }
                            return null;
                          }
                         
                          public static class Node {
                            private int data;
                            private Node left;
                            private Node right;
                         
                            public Node(int data) {
                              this.data = data;
                            }
                          }
                        }
    4. 二叉树查找树的插入操作
            (1) 中心思想：
                        新插入的数据一般都是在叶子节点上，只需要从根节点开始，依次比较要插入的数据和节点的大小关系。
                        如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；
                        如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，
                        并且节点的左子树为空， 就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，
                        查找插入位置。
            (2) 代码实现:
                        public void insert(int data) {
                          if (tree == null) 
                          {
                            tree = new Node(data);
                            return;
                          }
                         
                          Node p = tree;
                          while (p != null) 
                          {
                            if (data > p.data) 
                            {
                              if (p.right == null) 
                              {
                                p.right = new Node(data);
                                return;
                              }
                              p = p.right;
                            }
                            else 
                            { // data < p.data
                              if (p.left == null) 
                              {
                                p.left = new Node(data);
                                return;
                              }
                              p = p.left;
                            }
                            
                          }
                          
                        }
    5. 二叉树查找树的删除操作
            I. 中心思想:
                (1) 第一种情况: 如果要删除的节点没有子节点，可以直接删除(只需要直接将父节点中，指向要删除节点的指针置为 null)
                (2) 第二种情况: 如果要删除的节点只有一个子节点（只有左子节点(数据比要删除的数据小)或者右子节点
                              (数据比要删除的数据大)）, 只需要更新父节点中，由原先指向要删除节点的指针改为指向
                              要删除节点的子节点
                (3) 第三中情况: 如果要删除的节点有两个子节点,需要找到这个节点的右子树中的最小节点，
                               把它的数据替换到要删除的节点上, 然后再删除掉这个最小节点(采用第一种方案或则第二种方案)，
                                因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了）
                                
            II. 代码实现
                    public void delete(int data) 
                    {
                          Node p = tree; // p 指向要删除的节点，初始化指向根节点
                          Node pp = null; // pp 记录的是 p 的父节点
                          while (p != null && p.data != data) 
                          {
                            pp = p;
                            if (data > p.data) p = p.right;
                            else p = p.left;
                          }
                          if (p == null) return; // 没有找到
                         
                          // 要删除的节点有两个子节点
                          if (p.left != null && p.right != null) 
                          { // 查找右子树中最小节点
                            Node minP = p.right;
                            Node minPP = p; // minPP 表示 minP 的父节点
                            while (minP.left != null) 
                            {
                              minPP = minP;
                              minP = minP.left;
                            }
                            p.data = minP.data; // 将 minP 的数据替换到 p 中
                            p = minP; // 下面就变成了删除 minP 了
                            pp = minPP;
                          }
                         
                          // 删除节点是叶子节点或者仅有一个子节点
                          Node child; // p 的子节点
                          if (p.left != null) child = p.left;
                          else if (p.right != null) child = p.right;
                          else child = null;
                         
                          if (pp == null) tree = child; // 删除的是根节点
                          else if (pp.left == p) pp.left = child;
                          else pp.right = child;
                    }
                    
            III. 二叉查找树的删除操作还有个取巧的方法，就是单纯将要删除的节点标记为“已删除”，但并不真正从树中将
                 这个节点删除。 这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单
                 
    6. 二叉查找树可以输出有序的数据序列(中序遍历)，所以二叉查找树也被称为二叉排序树.
    7. 支持重复数据的二叉查找树
        在实际项目中通常利用对象的某个字段作为键值(key)来构建二叉查找树,通常把对象中的其他字段叫作卫星数据．
        处理重复数据的二叉树
        有两种方法:
                    方法一： 通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。
                    方法二:  每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值与要插入数据的值相同
                            就将这个插入的数据放到这个节点的右子树(把这个新插入的数据当作大于这个节点的值来处理)
                            
                            查找:
                                当要查找数据时，遇到值相同的节点不停止查找，而是继续在右子树中查找，直到遇到叶子节点
                                这样就可以把键值等于要查找值的所有节点都找出来。
                            删除:
                                先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。
    8. 二叉查找树的时间复杂度分析
            (1) 最理想的情况　O(logn), 二叉查找树是一棵完全二叉树（或满二叉树）,不管操作是插入、删除还是查找,
                时间复杂度其实都跟树的高度成正比，也就是 O(height), 那么时间复杂度的求解就是求一棵
                包含 n 个节点的完全二叉树的高度? 设该完全二叉树的层数为 L, 则满足 
                1 + 2 + 4.....2 ^ (L - 2) + 1 <= n < 1 + 2 +4 ......2 ^(L - 1)
                所以 L 的范围是 [log2 (n+1), log2 n + 1], 所以时间复杂度为 O(log n)
    9. 相对于散列表而言，有些场景使用二叉查找树的原因
            (1) 散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。对于二叉查找树来说，只需要中序遍历，
                 就可以在 O(n) 的时间复杂度内，输出有序的数据序列
            (2) 尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，
                            实际的查找速度可能不一定比 O(logn) 快, 再加上哈希函数的耗时，不一定就比平衡二叉查找树的
                            效率高
            (3) 散列表由于要减少冲突，设置了装载因子，在一定程度消耗内存．
            (4) 散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定,平衡二叉查找树的性能非常稳定，
                时间复杂度稳定在 O(logn)
            
            (5) 散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。
                平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。
    10. 二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于 log2 n 的情况，从而导致各个操作的效率下降。
        极端情况下，二叉树会退化为链表，时间复杂度会退化到 O(n)
           
```

## 红黑树(Red-Black Tree)

```shell
    1. 平衡二叉查找树: 二叉树中任意一个节点的左右子树的高度相差不能大于 1
    2. 平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，
       出现时间复杂度退化的问题。
    3. 设计一个新的平衡二叉查找树，只要树的高度不比 log2 n 大很多(比如树的高度仍然是对数量级的)，
       尽管它不符合严格意义平衡二叉查找树的定义，仍然可以说是一个合格的平衡二叉查找树。
    4. 有的时候我们所讲的平衡二叉树就是指红黑树,红黑树简称 R-B Tree,红黑树不是严格意义的平衡二叉树 ,
        红黑树从根到叶子的最长路劲不会超过最短路劲的 2 倍
    5. 红黑树的特点:
            (1) 一类被标记为黑色，一类被标记为红色
            (2) 根节点是黑色的
            (3) 每个叶子节点都是黑色的空节点(NIL)(叶子节点不存储数据),主要是为了简化红黑树的代码实现而设置的
            (4) 任何相邻的节点都不能同时为红色(红色节点是被黑色节点隔开的)
            (5) 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；
    6. 红黑树是近似平衡(性能不会退化的太严重),可以通过一步一步推导，首先现将红黑树的红色节点去掉，则有之前的
    　　二叉树变为四叉树,其四叉树的高度比包含相同节点个数的完全二叉树的高度还要小，完全二叉树的高度近似 log2 n,
       那么去掉红色节点的 "黑树" 高度也不会超过 log2 n, 这时再把红色节点加回去，则根据红色节点不能相邻，
       也就是说，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开。
       红黑树中包含最多黑色节点的路径不会超过 log2 n，加入红色节点后，最长路径不会超过 2 * log2 n，
       那么红黑树的高度近似 2 * log2 n。
    7. 实际项目中在平衡二叉查找树多用红黑树
             (1) Treap、Splay Tree，绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。
                 尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用。
             (2) AVL 树是一种高度平衡的二叉树,AVL 树为了维持这种高度的平衡,每次插入、删除都要做调整，就比较复杂、耗时
                 对于频繁的插入、删除操作的数据集合，使用 AVL 树的代价有点高
             (3) 红黑树只是近似平衡，在维护成本上要比 AVL 树要低，其插入、删除、查找各种操作性能都比较稳定
    8. 红黑树的平衡过程是遇到什么样的节点排布，就对应怎么去调整。只要按照这些固定的调整规则来操作，
    　　就能将一个非平衡的红黑树调整成平衡的。
    9. 插入和删除节点会使红黑树的特点(4), 特点(5) 失效.这个时候得用到左旋和右旋来平衡，左旋：对x进行左旋，意味着
       "将x变成一个左节点" 具体的实现是左右旋转和改变颜色等操作
    10. 插入操作的平衡调整
            (1) 插入的节点必须是红色的并且二叉查找树中新插入的节点都是放在叶子节点上
            (2) 两种特殊的插入情况
                    I. 如果插入节点的父节点是黑色的(即叶子节点的父节点)，那我们什么都不用做，
                    　 它仍然满足红黑树的定义(因为插入新的节点是红色的)
                    II. 如果插入的节点是根节点，那直接改变它的颜色，把它变成黑色就可以了。
            (3) 新节点插入之后，如果红黑树的平衡被打破，那一般会有下面三种情况(每一种情况对应不同的处理方式)
                    CASE 1 :
                             条件：如果关注节点是 a(红)，它的叔叔节点 d 是红色，依次执行下面的操作:
                             第一步: 将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色；
                             第二步: 将关注节点 a 的祖父节点 c 的颜色设置成红色；
                             第三步: 关注节点变成由 a 节点变为其祖父节点 c；
                             第四步: 跳到 CASE 2 或者 CASE 3
                             
                     注解: 其中 x, y, z, p, q 都是其他子树      
                       
                           c(黑)                                               c(红)  
                        /       \                                           /       \
                      b(红)       d(红)                                   b(黑)       d(黑)
                     /　　\　     /   \          -------->               /　　\　     /   \  
                    z     a(红)  p    q                                z     a(红)  p    q
                         /   \                                              /   \
                        x     y                                            x     y     
                        
                        
                    CASE 2:
                            条件：如果关注节点是 a(红)，叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点，
                            　　　依次执行下面的操作：
                                    第一步: 关注节点变成节点 a 的父节点 b；
                                    第二步: 围绕新的关注节点 b 左旋；
                                    第三步: 跳到 CASE 3
                                    
                    注解: 其中 x, y, z, p, q 都是其他子树  
                           c(黑)                                               c(黑)  
                        /       \                                           /       \
                      b(红)       d(黑)                                   a(红)       d(黑)
                     /　　\　     /   \          -------->               /　　\　     /   \  
                    z     a(红)  p    q                                b(红)  y     p    q
                         /   \                                       /   \
                        x     y                                     z     x     
                        
                    
                    CASE 3:
                            条件：如果关注节点是 a(红)，叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点，
                                 依次执行下面的操作：
                                    第一步: 围绕关注节点 a 的祖父节点 c 右旋；
                                    第二步: 将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。
                                    第三步: 调整结束
                    注解: 其中 x, y, z, p, q 都是其他子树  
                    
                              c(黑)                                         b(红)
                           /       \                                      /       \
                        b(红)       d(黑)                                a(红)       c(黑)
                       /　　\　     /   \      -------->                 /　　\　     /   \ 
                     a(红)  y     p    q                               z     x     y    d(黑) 
                    /   \                                                              /   \
                   z     x                                                            p    q
                   
                   
                   --------->                    b(黑)
                                              /       \
                                           a(红)       c(红)
                                          /　　\　     /   \ 
                                         z     x     y    d(黑) 
                                                         /   \
                                                        p    q
                                                        
    11. 删除操作的平衡调整
            (1) 删除操作的平衡调整分为两步:
                第一步是针对删除节点初步调整。初步调整只是保证整棵红黑树在一个节点删除之后，
            　　      仍然满足最后一条定义的要求(每个节点，从该节点到达其可达叶子节点的所有路径，
                     都包含相同数目的黑色节点)
                第二步是针对关注节点进行二次调整，让它满足红黑树的第三条定义(不存在相邻的两个红色节点)
            (2) 针对删除节点初步调整
                    I. 经过初步调整之后，为了保证满足红黑树定义的最后一条要求(个节点，从该节点到达其可达叶子节点的所有路径，
                       都包含相同数目的黑色节点)，有些节点会被标记成两种颜色，“红 - 黑”或者“黑 - 黑”。
                       如果一个节点被标记为了“黑 - 黑”，那在计算黑色节点个数时，要算成两个黑色节点
                    II.
                        CASE 1: 如果要删除的节点是 a，它只有一个子节点 b (不管是左子树还是右子树)
                                依次执行下面的操作：
                                    第一步: 删除节点 a，并且把节点 b 替换到节点 a 的位置
                                    第二步: 节点 a 只能是黑色，节点 b 也只能是红色(其他情况均不符合红黑树的定义)
                                           把节点 b 改为黑色；
                                    第三步: 调整结束，不需要进行二次调整。
                                    
                                      | 
                                    a(黑)                           |
                                        \                         b(黑)
                                          b(红)    ------>        /   \ 
                                         /   \ 
                                         
                        CASE 2: 如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c
                                依次执行下面的操作：
                                    第一步: 如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。
                                           把节点 a 删除，并且将节点 c 替换到节点 a 的位置。
                                    第二步: 然后把节点 c 的颜色设置为跟节点 a 相同的颜色；
                                    第三步: 如果节点 c 是黑色，为了不违反红黑树的最后一条定义(每个节点，
                                           从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点)，
                                           给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了
                                           “红 - 黑”或者“黑 - 黑”；
                                    第四步: 关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做
                                    
                                      |                                              |
                                  a(可红可黑)                                     c(可红可黑)
                                  /       \                                     /       \
                            b(可红可黑)     c(可红可黑)        ------>      b(可红可黑)     d(红 - 黑”或者“黑 - 黑”
                            /      \          \                           /      \      /      \
                                              d(可红可黑)
                                              /   \
                                              
                        CASE 3: 如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是 a 的右子节点
                                依次执行下面的操作：
                                    第一步: 找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 CASE 1；
                                    第二步: 将节点 a 替换成后继节点 d；
                                    第三步: 把节点 d 的颜色设置为跟节点 a 相同的颜色；
                                    第四步: 如果节点 d 是黑色，为了不违反红黑树的最后一条定义(每个节点，从该节点到达其
                                           可达叶子节点的所有路径，都包含相同数目的黑色节点)，给节点 d 的右子节点 c 
                                           多加一个黑色，这个时候节点 c 就成了“红 - 黑”或者“黑 - 黑”；
                                    第五步: 关注节点变成了节点 c，二次调整操作就会针对关注节点来做。
                                    
                                 |                                         |    
                             a(可红可黑)                                 d(可红可黑)
                             /       \                                 /       \    
                     b(可红可黑)     c(可红可黑)    ---->          b(可红可黑)     c(红 - 黑”或者“黑 - 黑)
                     /    \         /                             /    \         /
                                   d                                         e(可红可黑)
                                    \                                        /     \
                                   e(可红可黑)                                 
                                   /     \
                                   
            (3)  针对关注节点进行二次调整
                    I. 经过初步调整后，关注节点变成了“红 - 黑”或者“黑 - 黑”节点。针对这个关注节点，
                       再分四种情况来进行二次调整。二次调整是为了让红黑树中不存在相邻的红色节点。
                    II. CASE 1: 如果关注节点是 a，它的兄弟节点 c 是红色的
                                依次执行下面的操作：
                                    第一步: 围绕关注节点 a 的父节点 b 左旋；
                                    第二步: 关注节点 a 的父节点 b 和祖父节点 c 交换颜色；
                                    第三步: 关注节点不变；
                                    第四步: 继续从四种情况中选择适合的规则来调整。
                     注解: 其中 x, y, z, p, q 都是其他子树 
                                    
                                 b(黑)                                                        c(红)
                               /     \                                                  /            \  
              a(红 - 黑”或者“黑 - 黑)   c(红)              ---->                        b(黑)             e(黑) 
                   /    \             /        \                             /                \         /    \
                 x        y       d(黑)        e(黑)                    a(红 - 黑”或者“黑 - 黑)   d(黑)  p     q
                                /    \        /     \                       /    \             /  \
                               z      w      p       q                     x      y           z   w
                               
                               
                                                                          c(黑)
                             ---->                                    /            \    
                                                                 b(红)             e(黑)
                                                              /       \            /    \
                                                a(红 - 黑”或者“黑 - 黑)   d(黑)     p     q
                                                    /    \             /  \
                                                  x      y            z   w 
                                                  
                        CASE 2: 如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的
                                依次执行下面的操作：
                                    第一步: 将关注节点 a 的兄弟节点 c 的颜色变成红色；
                                    第二步: 从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；
                                    第三步: 给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了
                                           “红 - 黑”或者“黑 - 黑”；
                                    第四步: 关注节点从 a 变成其父节点 b；
                                    第五步: 继续从四种情况中选择符合的规则来调整。
                                    
                                b(可红可黑)                                     b(红 - 黑”或者“黑 - 黑)                  
                               /     \                                              /           \                     
              a(红 - 黑”或者“黑 - 黑)     c(黑)              ---->              a(可红可黑)       c(红)     
                   /    \             /        \                              /    \          /       \   
                 x        y       d(黑)        e(黑)                         x       y       d(黑)      e(黑) 
                                /    \        /     \                                       /    \    /     \  
                               z      w      p       q                                    z      w   p       q
                               
                               
                       CASE 3：　如果关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色，
                       　　　　　 依次执行下面的操作：
                                    第一步: 围绕关注节点 a 的兄弟节点 c 右旋；
                                    第二步: 节点 c 和节点 d 交换颜色；
                                    第三步: 关注节点不变；
                                    第四步: 跳转到 CASE 4，继续调整。
                                    
                                 b(可红可黑)                                        b(可红可黑) 
                               /     \                                          /              \  
              a(红 - 黑”或者“黑 - 黑)   c(黑)              ---->  a(红 - 黑”或者“黑 - 黑)         d(红) 
                   /    \             /       \                  /                \         /    \
                 x        y       d(红)        e(黑)            x                   y      z      c(黑)
                                /    \        /     \                                            /   \
                               z      w      p       q                                         w     e(黑)                                 
                                                                                                      /   \
                                                                                                     p     q
                                                                                                     
                                                                    b(可红可黑) 
                                                               /              \  
                                      ---->    a(红 - 黑”或者“黑 - 黑)         d(黑) 
                                                /                \         /    \
                                               x                   y      z      c(红)
                                                                               /   \
                                                                             w     e(黑)                                 
                                                                                  /   \
                                                                                 p     q     
                                                                                                          
                      　CASE 4: 如果关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的，
                                依次执行下面的操作：
                                     第一步: 围绕关注节点 a 的父节点 b 左旋；
                                     第二步: 将关注节点 a 的祖父节点 c 的颜色，跟关注节点 a 的父节点 b 
                                            设置成相同的颜色；
                                     第三步: 将关注节点 a 的父节点 b 的颜色设置为黑色；
                                     第四步: 从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；
                                     第五步: 将关注节点 a 的叔叔节点 e 设置为黑色；
                                     第六步: 调整结束。
                        b(可黑可红)                                                   c(黑)
                       /     \                                                  /            \  
      a(红 - 黑”或者“黑 - 黑)    c(黑)              ---->                 b(可红可黑)             e(红) 
           /    \             /        \                             /            \       　 /    \
         x        y       d(可黑可红)   e(红)           　a(红 - 黑”或者“黑 - 黑)   d(可红可黑)  p     q
                        /    \        /     \                       /    \         /  \
                       z      w      p       q                     x      y       z   w                                     
 
                                                           c(可红可黑)
                                                        /            \  
     　　　　 　　　        ---->                    b(黑)             e(黑) 
          　　　　　                           /            \       　 /    \
       　　　　　　　　                   　a(可红可黑)   d(可红可黑)  　p     q
                     　　                 /    \         /  \
      　　　　　　　　　　                  x      y       z   w                                    
                               
```

# 递归树

```shell
    1. 借助递归树来分析递归算法的时间复杂度
    2. 通过递归树来分析归并排序的时间复杂度
            每次分解都是一分为二，代价很低时间上的消耗记作常量 1。归并算法中比较耗时的是归并操作，
    　　 　  也就是把两个子数组合并为大数组。每一层归并操作消耗的时间总和是一样的(第一层是 n, 
    　　　　 第二层是 n / 2 + n / 2 也为 n)， 跟要排序的数据规模有关。把每一层归并操作消耗的时间记作 n。
    　　　　 这样总的时间复杂度只需要知道这棵树的高度 h， 用高度 h 乘以每一层的时间消耗 n，就可以得到总的
            时间复杂度 O(n∗h)。 从归并排序的原理和递归树，归并排序递归树是一棵满二叉树。满二叉树的高度大约是 log2 n，
            所以，归并排序递归实现的时间复杂度就是 O(nlogn)
    3. 通过递归树来分析快速排序的时间复杂度
            设平均情况下，每次分区之后，两个分区的大小比例为 1:k(在最好的情况下 2 个分区的个数比例为 1:1),假设 k 为 9,
            每次分区都将长度分成 1:9, 快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历
            的数据的个数之和就是 n。只要求出递归树的高度 h，这个快排过程遍历的数据个数就是 h ∗ n ，
            其时间复杂度就是 O(h∗n), 快速排序结束的条件就是待排序的小区间，大小为 1，从根节点 n 到叶子节点 1，
            递归树中最短的一个路径每次都乘以 1/10，最长的一个路径每次都乘以 9/10,例如最短的个数层次: n, 1/10 * n,
            1/10^2 * n,....1, 最短路劲 h = log10 n, 对应的最长路劲 h = log10/9 n, 所以时间复杂度是介于
            O(n * log10 n) 和 O(n * log10/9 n) 之间，所以时间复杂度为 O(n * logn)
            只要 k 的值不随 n 变化，是一个事先确定的常量，那快排的时间复杂度就是 O(n * logn)。
    4. 通过递归树来分析斐波那契数列的时间复杂度
            递归树的高度，f(n) 分解为 f(n−1) 和 f(n−2)，每次向下一层数据规模都是 −1(减 1) 或者 −2(减 2)，
            叶子节点的数据规模是 1 或者 2。所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是 −1，
            那最长路径大约就是 n； 如果每次都是 −2，那最短路径大约就是 n/2.
            每次分解之后的合并操作只需要一次加法运算，把这次加法运算的时间消耗记作 1。从上往下，第一层的总时间消耗是 1，
            第二层的总时间消耗是 2，第三层的总时间消耗就是 2^2。依次类推，第 k 层的时间消耗就是 2^(k−1)，
            那整个算法的总的时间消耗就是每一层时间消耗之和。
            如果路径长度都为 n 时, 1 + 2 + 2^2 + ......2^(n - 1) = 2^n − 1
            如果路径长度都为 n/2 时, 1 + 2 + 2^2 + ......2^(n/2 - 1) = 2^(n/2) − 1
            随意时间复杂度介于 O(2^n) 和 O(2^(n/2)) 之间
    5. 通过递归树来分析全排列的时间复杂度
            
```

# 堆

```shell
    1. 堆的特点:
            (1) 堆是一个完全二叉树
            (2) 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。
                    大顶堆: 每个节点的值都大于等于子树中每个节点值的堆
                    小顶堆: 每个节点的值都小于等于子树中每个节点值的堆
    2. 存储一个堆
            堆(完全二叉树)比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间。因为不需要存储左右子节点的指针，
            单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。
    3. 堆的操作
            (1) 往堆中插入一个元素
                    I. 向堆中插入元素后需要继续满足堆的两个特性，一般插入一个元素，是将该元素插入到数组的最后一个位置
                    II 堆化(调整堆使其满足堆的两个特性)
                            顺着节点所在的路径，向上或者向下，对比，然后交换
                            a. 从下往上的堆化方法, 让新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，
                               就互换两个节点。一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。
                               
                                public class Heap {
                                  private int[] a; // 数组，从下标 1 开始存储数据
                                  private int n;  // 堆可以存储的最大数据个数
                                  private int count; // 堆中已经存储的数据个数
                                 
                                  public Heap(int capacity) {
                                    a = new int[capacity + 1];
                                    n = capacity;
                                    count = 0;
                                  }
                                 
                                  public void insert(int data) {
                                    if (count >= n) return; // 堆满了
                                    ++count;
                                    a[count] = data;
                                    int i = count;
                                    while (i/2 > 0 && a[i] > a[i/2]) { // 自下往上堆化
                                      swap(a, i, i/2); // swap() 函数作用：交换下标为 i 和 i/2 的两个元素
                                      i = i/2;
                                    }
                                  }
                                 }
                                      
            (2) 删除堆顶元素
                    在删除堆顶时为了保证堆特性(堆始终满足完全二叉树),删除操作由一开始在堆顶删除，第二大值比较上移改为
                    把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的
                    (这时需要比较左右节点哪个大)， 互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。
                    这就是从上往下的堆化方法。
                    因为移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，
                    满足完全二叉树的特性。
                    
                    public void removeMax() {
                      if (count == 0) return -1; // 堆中没有数据
                      a[1] = a[count];
                      --count;
                      heapify(a, count, 1);
                    }
                     
                    private void heapify(int[] a, int n, int i) { // 自上往下堆化
                      while (true) {
                        int maxPos = i;
                        if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
                        if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
                        if (maxPos == i) break;
                        swap(a, i, maxPos);
                        i = maxPos;
                      }
                    }
    4. 一个包含 n 个节点的完全二叉树，树的高度不会超过 log2 n。
        插入数据和删除堆顶元素的主要逻辑就是堆化，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)
                                             
```

# 堆排序

```shell
    1. 堆排序: 借助堆的数据结构实现的排序算法
    2. 堆排序的步骤
            第一步: 建堆(原地建堆)
                        思路一: 在堆中插入一个元素的思路。起初堆中只包含一个数据，就是下标为 1 的数据。然后调用插入操作
                        　　　　(插入到最后再进行堆化)，将下标从 2 到 n 的数据依次插入到堆中。这样就将包含 n 个数据的数组，
                               组织成了堆。
                        思路二: 在数据已经填充到数组中，但还没进行堆化，需要由后往前处理数组，每个数据都是从上往下堆化，
                        　　　　即需要由后取到最后一个父节点，再依次右子树，左子树顺序向前堆化.
                               堆化从数组下标从 n/2 开始往前到下标 1 的数据，下标 n/2 + 1 到 n 的节点是叶子节点，
                               不需要堆化
                                    private static void buildHeap(int[] a, int n) {
                                      for (int i = n/2; i >= 1; --i) {
                                        heapify(a, n, i);
                                      }
                                    }
                                     
                                    private static void heapify(int[] a, int n, int i) {
                                      while (true) {
                                        int maxPos = i;
                                        if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
                                        if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
                                        if (maxPos == i) break;
                                        swap(a, i, maxPos);
                                        i = maxPos;
                                      }
                                    }
                                    
                    建堆的时间复杂度 O(n), 每个节点堆化的过程，需要比较和交换的节点个数，跟这个节点的高度 k 成正比。
                    其中第一层节点个数为 1, 高度为 h, 第二层节点个数为 2, 高度为 h - 1, 第 h 层节点个数为 2^(h - 1),
                    高度为 1, S = h + 2 * (h - 1) + 2^2 * (h - 2) ...... + 2^(h - 1)
                    S = 2 * S - S = 2 * h + 2^2 * (h - 1) + 2^3 * (h -2) .....+ 2^h 
                                                -
                                    (h + 2 * (h - 1) + 2^2 * (h - 2) ...... + 2^(h - 1))
                                  = -h + 2 + 2^2 + 2^3 + .....2^h
                                  = 2^(h + 1) - 2 - h     (又因为 h = log2 n)
                                  = 2^(log2 n + 1) -2 -log2 n
                                  = 2 * n -2 -log2 n
                                  
                    所以 O(S) = O(n)
            第二步: 排序
                        就是根据大顶堆将数组由大到小排序，数组中的第一个元素就是堆顶，也是最大的元素，把它跟最后一个元素交换，
                        那最大元素就放到了下标为 n 的位置。当堆顶元素移除之后，把下标为 n 的元素放到堆顶，
                        然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆。堆化完成之后，再取堆顶的元素，
                        放到下标是 n−1 的位置，一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了。
                        
                        // n 表示数据的个数，数组 a 中的数据从下标 1 到 n 的位置。
                        public static void sort(int[] a, int n) {
                          buildHeap(a, n);
                          int k = n;
                          while (k > 1) {
                            swap(a, 1, k);
                            --k;
                            heapify(a, k, 1);
                          }
                        }
                        
    3. 堆排序的性能分析
            (1) 堆排序是原地排序算法
            (2) 堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，
                所以，堆排序整体的时间复杂度是 O(nlogn)
            (3) 堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，
               所以就有可能改变值相同数据的原始相对顺序
               
    4. 快速排序要比堆排序性能好
            (1) 堆排序数据访问的方式没有快速排序友好
                    在排序的过程中，快排的访问是顺序访问(分区操作)，而堆排序中堆化操作会跳着访问(比较父节点的值)，
                    对 CPU 缓存是不友好的
            (2) 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序.
                在每次堆化的过程中都会将原有的有序度打乱
   　5. 堆的使用场景
            (1) 优先级队列
                    往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，
                    就相当于取出堆顶元素.
                    优先级队列应用场景很广泛，例如赫夫曼编码，图的最短路径、最小生成树算法，Java 的 PriorityQueue，
                    C++ 的 priority_queue 等。
                    
                    a. 合并有序小文件
                            有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串,
                            将这些 100 个小文件合并成一个有序的大文件.
                            思路: 从这 100 个文件中，各取第一个字符串，放入数组中，然后比较大小，
                                  把最小的那个字符串放入合并后的大文件中，并从数组中删除,那么这个数组就可以用小顶堆来实现
                                  刚开始从 100 个文件中各取第一个字符串，进行建堆，
                                  从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，
                                  就是最小的字符串。将这个字符串放入到大文件中，并将其从堆中删除。然后再从对应小文件中取出
                                  下一个字符串，放入到堆中(期间要进行堆化)。循环这个过程，就可以将 100 个小文件中的数据
                                  依次放入到大文件中。
                    b. 高性能定时器
                            用优先级队列既不用间隔 1 秒就轮询一次，也不用遍历整个任务列表
                            思路: 按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（也就是小顶堆的堆顶）存储的是
                                 最先执行的任务。 这样，定时器就不需要每隔 1 秒就扫描一遍任务列表。它拿队首任务的执行时间点，
                                 与当前时间点相减，得到一个时间间隔 T。 定时器可以设定在 T 秒之后，再来执行任务。
                                 从当前时间点到（T-1）秒这段时间里，定时器都不需要做任何事情。
                                 当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点
                                 与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。
            (2) Top K
                    a. 针对静态数据集合(数据集合事先确定，不会再变)在一个包含 n 个数据的数组中，查找前 K 大数据
                            维护一个大小为 K 的小顶堆，在顺序遍历数组，从数组中取出取数据与堆顶元素(最小值)比较。
                            如果比堆顶元素大，就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，
                            继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据。
                            
                            时间复杂度：遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK) 的时间复杂度，
                            　　　　　　所以最坏情况下，　n 个元素都入堆一次，时间复杂度就是 O(n * logK)
                    b. 针对动态数据，在已经维护了一个 k 大小的小顶堆，当要查询这时的 top k 的数据，直接返回，如果是新增了
                    　　一个数据，则需要与堆顶比较，该数据如果比堆顶元素大，则将堆顶元素删除，在将该新增元素出入到堆中(期间
                    　　可能要进行堆化)
                    
                                  
```

