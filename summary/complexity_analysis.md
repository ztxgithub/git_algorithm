# 复杂度分析

## 复杂度分析的意义

```shell
    1. 复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。
    2. 和复杂度分析(理论值)相比，事后统计法(将代码跑一遍，统计和监控内存占用大小和 执行的时间)具体一点局限性
            (1) 测试结果依赖测试环境，例如操作系统，硬件等
            (2) 测试结果跟数据规模和数据分布有关
                    对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。极端情况下，
                    如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。
                    如果测试数据规模太小，测试结果可能无法真实地反应算法的性能。比如，
                    对于小规模的数据排序，插入排序可能反倒会比快速排序要快
```

## 大 O 复杂度表示法

```shell
    1. 大 O 时间复杂度表示法: T(n) = O(2 * n + 2)， T(n) = O(2 * n ^ 2 + 2 * n + 3 ), 
       其中　O　表示代码的执行时间 T(n) 与 f(n) 表达式成正比，即 T(n) 与 (2 * n + 2)) 成正比
       当 n 很大时(n -> 正无穷大)，公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。
       只需要记录一个最大量级就可以，即：T(n) = O(n)； T(n) = O(n ^ 2)。
```
       
## 时间复杂度
```shell
    1. 时间复杂度分析技巧
            (1) 加法法则：总的时间复杂度就等于量级最大的那段代码的时间复杂度
                    因为 O 这种复杂度表示方法只是表示一种变化趋势。忽略掉公式中的常量、低阶、系数，
                    只需要记录一个最大阶的量级就可以
                    例如:
                             int cal(int n) {
                               int sum = 0;
                               int i = 1;
                               for (; i <= n; ++i) {
                                 sum = sum + i;
                               }
                               return sum;
                             }
                             
                            　则 cal 函数的时间复杂度为 T(n) = O(n)
                            
                            int max_cal(int n) {
                               int sum_1 = 0;
                               int p = 1;
                               for (; p < 100; ++p) {
                                 sum_1 = sum_1 + p;
                               }
                             
                               int sum_2 = 0;
                               int q = 1;
                               for (; q < n; ++q) {
                                 sum_2 = sum_2 + q;
                               }
                             
                               int sum_3 = 0;
                               int i = 1;
                               int j = 1;
                               for (; i <= n; ++i) {
                                 j = 1; 
                                 for (; j <= n; ++j) {
                                   sum_3 = sum_3 +  i * j;
                                 }
                               }
                             
                               return sum_1 + sum_2 + sum_3;
                             }
                             
                             则 max_cal 函数的时间复杂度为 T(n) = O(n ^ 2)
                            
            (2) 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
            
    3. 
        (1) 多项式量级(复杂度量级)：　常量阶 O(1), 对数阶 O(log n), 线性阶　O(n)
                                   线性对数阶　O(n * log n),  k 次方阶(O(n ^ k))
                                   
        (2) 非确定性多项式：　指数阶　O( 2 ^ n),  阶乘阶(n!)
        
        (3) O(1): 代码的执行时间不随 n 的增大而增长, 只要算法中不存在循环语句、递归语句，
                 即使有成千上万行的代码，其时间复杂度也是Ο(1)。
        (4) O(logn): 例如：
        
                 i=1;
                 while (i <= n)  {
                   i = i * 3;
                 }
                 
                 这段代码执行的次数跟 i 的值有关，　2 ^ x = n, --> x=log2 n, 所以　O(log2n)，
                 当 n 接近与无穷大时，　O(log2　n)　约等于 O(logn）
        (5) O(n * logn) : 归并排序、快速排序
        (6)  O(m+n)
        
                int cal(int m, int n) {
                  int sum_1 = 0;
                  int i = 1;
                  for (; i < m; ++i) {
                    sum_1 = sum_1 + i;
                  }
                 
                  int sum_2 = 0;
                  int j = 1;
                  for (; j < n; ++j) {
                    sum_2 = sum_2 + j;
                  }
                 
                  return sum_1 + sum_2;
                }
                
                m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，
                省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。
```

## 空间复杂度

```shell
    1.　就是在代码运行过程中占用多少存储空间，常见的空间复杂度就是 O(1)、O(n)、O(n ^ 2 ) 
```

## 深入应用

```shell
    1. 最好情况时间复杂度： best case time complexity
       最坏情况时间复杂度： worst case time complexity
       平均情况时间复杂度:  average case time complexity: 可能得考虑到各种情况发生的概率．
       均摊时间复杂度   :  amortized time complexity
       
    2. 在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。
       很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，
       我们才会使用这三种复杂度表示法来区分。
       
    3. 均摊时间复杂度
        对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，
        而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，
        看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，
        在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度
```