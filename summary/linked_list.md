# 链表(缓冲 LRU 的应用)

## 基础知识

```shell
    1. 缓存淘汰策略
            (1) 先进先出策略 FIFO（First In，First Out）
            (2) 最少使用策略 LFU（Least Frequently Used）
            (3) 最近最少使用策略 LRU（Least Recently Used）
    
```

## 链表方面

```shell
    1. 单向链表和双向链表的区别
           (1) 在删除节点上，如果已经找到对应的节点，需要删除这个节点还需要得到前驱节点，而对于单向链表而言需要从头开始
               遍历才能找到该节点的前驱节点(时间复杂度为 O(n))，而双向链表可以直接得到前驱节点(时间复杂度 O(1))
           (2) 对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。可以记录上次查找的位置 p，每次查询时，
               根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。
```

## 快慢指针

```shell
    1. 对于单向链表而言，快指针向后移动 2 步(ptr->next->next), 慢指针向后移动 1 步(ptr->next), 这样可以得到链表
    　 中间的节点．
    2. 快慢指针的应用
            (1) 判断该链表是否为循环链表
                    循环链表的定义：循环链表不仅仅是尾指针指向头指针这一种，还可能是尾指针指向该链表中某个节点．
                    优化思路： 如果是有一个指针跑的快的并且该链表是循环(一个环)，那么快指针总会比慢指针快一圈并且追到．
                    　　　　　　例如：快指针每次走 2 个节点，慢指针每次只走 1 个节点。
                    　　　　　　如果快指针到达NULL，说明链表以NULL为结尾，不是循环链表。如果 快指针追上慢指针，则表示出现了循环
                    代码:
                     
                        LinkList fast, slow;
                        fast = slow = L;
                        while (fast && fast->next)
                        {
                            slow = slow->next;
                            fast = fast->next->next;
                            if (slow == fast)
                            {
                                break;
                            }
                        }
                        
            (2) 如果链表存在环，则如何找到环的入口节点
                    设链起点到环入口点间的距离为x，环入口点到 fast 与 low 重合点的距离为 y，
                    fast 与 low 重合时 fast 已绕环n周（n>0），且此时 low 移动总长度为 s，则 fast 移动总长度为2s，
                    环的长度为r。则
                             s + nr = 2s,n>0      ①
                             s = x + y            ②
                             可以得出:
                              nr = x + y, 
                              
                    思路: 由 nr = x + y 可以知道，结合画图，如果指针 p1 从链表起点处开始遍历，指针 p2 从 fast 与 low 重合节点
                         处开始遍历，且 p1 和 p2 移动步长均为1, 当指针 p1 到达重合点时，刚好指针 p2　从重合点开始绕了 n 圈.
                         由于 2 个指针右一起走了 y 步，所以是在环的入口节点就相遇了.
                         
                    代码:
                        
                            Node* findEntry(Node* head, Node* encounter)
                            { 
                                Node *p1 = head, *p2 = encounter;
                                while(p1 != p2)
                                {
                                    p1 = p1->next;
                                    p2 = p2->next;
                                }
                                return p1;
                            }

                        
            (3) 在有序链表中寻找中位数
                    如果链表节点总数是奇数，当快指针到达链表尾时，则慢指针对应的是数据就是中位数.
                    如果链表节点总数是偶数，则快指针到达倒数第二个节点时，则此时慢指针对应的数据和慢指针下一个数据的平均数
                    是中位数．
                    
            (4) 两个单链表是否相交
                    思路: 将其中一个链表首尾相连，检测另外一个链表是否存在环，如果存在，则两个链表相交，
                          而检测出来的依赖环入口即为相交的第一个点。
                          
                          []->[]->[]->[]->[]
                                 |
                          []->[]->
                          
            (5) 取链表倒数第 n 个节点
                    思路: 置快指针步长为n，然后快慢指针同时以同一速度走，当快指针到达链表尾时，慢指针对应的就
                         是倒数第 n 个节点           
```

## 链表技巧

```shell
    1.利用哨兵简化编程难度
            哨兵结点就是第一个头节点没有数据，真正的有数据的结点是哨兵节点的下一个节点，这样设计有个好处是
            插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码。
```

## 链表的应用

```shell
    1.链表的反转
         struct LinkNode_t{
            int value;
            sturct LinkNode_t *next;
         }LinkNode;
        (1) 递归方案:
                LinkNode* ReverseList(LinkNode *head)
                {
                    if(!head || !head->next)  // 主要是拿到链表的最后一个节点
                        return head;
                    
                    LinkNode *new_head = ReverseList(head->next);
                    head->next->next = head;
                    head->next = NULL;
                    return new_head;　// 返回的始终是反转后的头节点
                }
                
        (2) 非递归方案:
                LinkNode* ReverseList(LinkNode *head)
                {
                    if(!head || !head->next)  // 考虑空指针或则链表中只有一个节点的情况
                        return head;
                        
                    LinkNode* prev = head;
                    LinkNode* cur = head->next;
                    LinkNode* tmp = cur->next;
                    while(cur)
                    {
                        tmp = cur->next;
                        cur->next = prev;
                        prev = cur;
                        cur = tmp;
                    }
                    head->next = NULL;
                    return prev;
                }
```

## 总结

```shell
    1.链表有单向链表，双向链表，循环链表，常用的是双向链表
```

# 跳表(Skip list)

```shell
    1. (1) 顺序表可以使用二分查找，而普通的链表不行，
    　     需要对链表稍加改造，就可以支持类似“二分”的查找算法，这个改造后的链表称之为跳表
       (2) 跳表是动态数据结构，可以支持快速的插入、删除、查找操作，甚至可以替代红黑树（Red-black tree）
       (3) 跳表是链表加多级索引的结构，主要的方式是在原始的链表上建立一级“索引，每两个结点提取一个结点到上一级(索引层)．
       　　其中索引级的数据结构有 2 个指针，第一个是 down 指针，指向下一层级的结点，第二个是 next 指针，指向同一层级下一个指针
       　　例如：定义了原始链表(第一级)，在原始链表中每 2 个结点取一个当索引层的结点，那么索引层的结点个数比原始链表中结点个数要
       　　　　　少一半．如果我们现在要查找某个结点，比如 16。我们可以先在索引层遍历，当遍历到索引层值为 13 的结点时，
       　　　　　发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点(13 和 17)之间。然后我们通过索引层结点的 down 指针，
               下降到原始链表这一层，继续遍历。这时只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点。
               这样，原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。
               
       (4) 时间复杂度 O(logn)
                每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4
                第 k级索引结点的个数就是 n/(2 ^ k), 所以最高级的索引有 2 个结点， n/(2 ^ k) = 2, 则 k = log2 n - 1, 
                如果包含原始链表这一层，整个跳表的高度就是 log2 n。在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，
                那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。
       (5) 空间复杂度 O(n)
                假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点, 
                 n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的空间复杂度是 O(n)。也就是说，如果将包含 n 个结点的单链表构造成跳表，
                 我们需要额外再用接近 n 个结点的存储空间.减少存储空间可以采用原始链表由每隔 2 个结点上升 1 个索引结点，改为
                 每隔 10 个结点上升为 1 个结点.
       (6) 动态插入
                对应链表来说插入方便，主要是查找到对应的位置，跳表查找某个结点的的时间复杂度是 O(logn)，插入后，跳表
                还要实现索引动态更新．
       (7) 跳表索引动态更新
                当我们不停地往跳表中插入数据时，如果不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。
                极端情况下，跳表还会退化成单链表.跳表主要是通过随机函数来维护平衡性，通过一个随机函数，
                来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中
                (在第一级到第 K 级都有)。
       (8) 应用
                Redis 使用跳表而不是红黑树来实现有序集合，因为 Redis 不关要有插入、删除、查找等操作，还要有按照区间来查找数据这个操作，
                红黑树的效率没有跳表高，跳表可以做到 O(logn) 的时间复杂度来定位区间的起点，然后在原始链表中顺序往后遍历就可以，
                Redis　很灵活， 当内存占用达到一个阈值之后 可以启动 LRU 等缓存淘汰算法或者将数据存到硬盘
                
       () 总结
            在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，
            所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略。
            跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗
```