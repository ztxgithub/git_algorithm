# 二叉树

## 基础知识

```shell
    1.结点的高度 = 该结点到叶子结点的最长路劲(边数)
      结点的深度 = 根节点到到这个结点所经历的边的个数
      结点的层数 = 结点的深度 + 1
      树的高度 =  根结点的高度
      
    2. 满二叉树: 叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点
       完全二叉树: 叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大
    3. 前驱结点：节点 val 值小于该节点 val值 并且值最大的节点 
       后继节点：节点 val 值大于该节点 val 值并且值最小的节点
    
```

## 存储二叉树

```shell
    1. 链式存储法(常用,链表)
        每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针,只要拿到根结点就能遍历整个二叉树
    2. 顺序存储法(基于数组)
            把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。
            以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置
            
            如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的
            就是右子节点。 下标为 i/2 的位置存储就是它的父节点。只要知道根节点存储的位置(为了方便计算子节点，根节点会存储
            在下标为 1 的位置)，　就可以通过下标计算，把整棵树都串起来
            
            (1) 完全二叉树仅仅“浪费”了一个下标为 0 的存储位置。如果是非完全二叉树，会浪费比较多的数组存储空间
                如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式,
            (2) 数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。
            
```

## 遍历二叉树

```shell
    主要前，中，后是针对当前结点而言
    1. 前序遍历
            (1) 对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
            (2) 前序遍历的递推公式： preOrder(r) = print r -> preOrder(r->left) -> preOrder(r->right)
            (3) 代码:
                    void preOrder(Node* root) {
                      if (root == null) return;
                      print root // 此处为伪代码，表示打印 root 节点
                      preOrder(root->left);
                      preOrder(root->right);
                    }

    2. 中序遍历
            (1) 对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
            (2) 中序遍历的递推公式： inOrder(r) =  inOrder(r->left) ->  print r -> inOrder(r->right)
            (3) 代码:
                    void inOrder(Node* root) {
                      if (root == null) return;
                      inOrder(root->left);
                      print root // 此处为伪代码，表示打印 root 节点
                      inOrder(root->right);
                    }
    3. 后序遍历
            (1) 对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。
            (2) 后序遍历的递推公式: postOrder(r) = postOrder(r->left) -> postOrder(r->right) -> print r
            (3) 代码:
                    void postOrder(Node* root) {
                      if (root == null) return;
                      postOrder(root->left);
                      postOrder(root->right);
                      print root // 此处为伪代码，表示打印 root 节点
                    }
                    
    4. 层序遍历(广度优先遍历) : 借用队列辅助即可，根节点先入队列，然后循环从队列中pop节点，将pop出来的节点的左子节点先入队列，
                             右节点后入队列，依次循环，直到队列为空，遍历结束
                    
    5. 二叉树遍历的时间复杂度是 O(n), 每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比
    
```

## 二叉查找树(Binary Search Tree)

```shell
    1. 二叉查找树也叫二叉搜索树，二叉查找树是为了实现快速查找而生的
    2. 二叉查找树最大的特点就是，支持动态数据集合的快速插入、删除、查找操作，能够实现这些特性依赖于特殊结构，
       二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值
       二叉查找树也有可能极度不平衡(二叉查找树的高度为 n)
    3. 二叉树查找树的查找操作
            (1) 中心思想:
                        先取根节点，如果它等于要查找的数据，就返回。如果要查找的数据比根节点的值小，就在左子树中递归查找；
                        如果要查找的数据比根节点的值大，就在右子树中递归查找。
            (2) 代码实现:
                        public class BinarySearchTree {
                          private Node tree;
                         
                          public Node find(int data) {
                            Node p = tree;
                            while (p != null) {
                              if (data < p.data) p = p.left;
                              else if (data > p.data) p = p.right;
                              else return p;
                            }
                            return null;
                          }
                         
                          public static class Node {
                            private int data;
                            private Node left;
                            private Node right;
                         
                            public Node(int data) {
                              this.data = data;
                            }
                          }
                        }
    4. 二叉树查找树的插入操作
            (1) 中心思想：
                        新插入的数据一般都是在叶子节点上，只需要从根节点开始，依次比较要插入的数据和节点的大小关系。
                        如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；
                        如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，
                        并且节点的左子树为空， 就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，
                        查找插入位置。
            (2) 代码实现:
                        public void insert(int data) {
                          if (tree == null) 
                          {
                            tree = new Node(data);
                            return;
                          }
                         
                          Node p = tree;
                          while (p != null) 
                          {
                            if (data > p.data) 
                            {
                              if (p.right == null) 
                              {
                                p.right = new Node(data);
                                return;
                              }
                              p = p.right;
                            }
                            else 
                            { // data < p.data
                              if (p.left == null) 
                              {
                                p.left = new Node(data);
                                return;
                              }
                              p = p.left;
                            }
                            
                          }
                          
                        }
    5. 二叉树查找树的删除操作
            I. 中心思想:
                (1) 第一种情况: 如果要删除的节点没有子节点，可以直接删除(只需要直接将父节点中，指向要删除节点的指针置为 null)
                (2) 第二种情况: 如果要删除的节点只有一个子节点（只有左子节点(数据比要删除的数据小)或者右子节点
                              (数据比要删除的数据大)）, 只需要更新父节点中，由原先指向要删除节点的指针改为指向
                              要删除节点的子节点
                (3) 第三中情况: 如果要删除的节点有两个子节点,需要找到这个节点的右子树中的最小节点，
                               把它的数据替换到要删除的节点上, 然后再删除掉这个最小节点(采用第一种方案或则第二种方案)，
                                因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了）
                                
            II. 代码实现
                    public void delete(int data) 
                    {
                          Node p = tree; // p 指向要删除的节点，初始化指向根节点
                          Node pp = null; // pp 记录的是 p 的父节点
                          while (p != null && p.data != data) 
                          {
                            pp = p;
                            if (data > p.data) p = p.right;
                            else p = p.left;
                          }
                          if (p == null) return; // 没有找到
                         
                          // 要删除的节点有两个子节点
                          if (p.left != null && p.right != null) 
                          { // 查找右子树中最小节点
                            Node minP = p.right;
                            Node minPP = p; // minPP 表示 minP 的父节点
                            while (minP.left != null) 
                            {
                              minPP = minP;
                              minP = minP.left;
                            }
                            p.data = minP.data; // 将 minP 的数据替换到 p 中
                            p = minP; // 下面就变成了删除 minP 了
                            pp = minPP;
                          }
                         
                          // 删除节点是叶子节点或者仅有一个子节点
                          Node child; // p 的子节点
                          if (p.left != null) child = p.left;
                          else if (p.right != null) child = p.right;
                          else child = null;
                         
                          if (pp == null) tree = child; // 删除的是根节点
                          else if (pp.left == p) pp.left = child;
                          else pp.right = child;
                    }
                    
            III. 二叉查找树的删除操作还有个取巧的方法，就是单纯将要删除的节点标记为“已删除”，但并不真正从树中将
                 这个节点删除。 这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单
                 
    6. 二叉查找树可以输出有序的数据序列(中序遍历)，所以二叉查找树也被称为二叉排序树.
    7. 支持重复数据的二叉查找树
        在实际项目中通常利用对象的某个字段作为键值(key)来构建二叉查找树,通常把对象中的其他字段叫作卫星数据．
        处理重复数据的二叉树
        有两种方法:
                    方法一： 通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。
                    方法二:  每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值与要插入数据的值相同
                            就将这个插入的数据放到这个节点的右子树(把这个新插入的数据当作大于这个节点的值来处理)
                            
                            查找:
                                当要查找数据时，遇到值相同的节点不停止查找，而是继续在右子树中查找，直到遇到叶子节点
                                这样就可以把键值等于要查找值的所有节点都找出来。
                            删除:
                                先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。
    8. 二叉查找树的时间复杂度分析
            (1) 最理想的情况　O(logn), 二叉查找树是一棵完全二叉树（或满二叉树）,不管操作是插入、删除还是查找,
                时间复杂度其实都跟树的高度成正比，也就是 O(height), 那么时间复杂度的求解就是求一棵
                包含 n 个节点的完全二叉树的高度? 设该完全二叉树的层数为 L, 则满足 
                1 + 2 + 4.....2 ^ (L - 2) + 1 <= n < 1 + 2 +4 ......2 ^(L - 1)
                所以 L 的范围是 [log2 (n+1), log2 n + 1], 所以时间复杂度为 O(log n)
    9. 相对于散列表而言，有些场景使用二叉查找树的原因
            (1) 散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。对于二叉查找树来说，只需要中序遍历，
                 就可以在 O(n) 的时间复杂度内，输出有序的数据序列
            (2) 尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，
                            实际的查找速度可能不一定比 O(logn) 快, 再加上哈希函数的耗时，不一定就比平衡二叉查找树的
                            效率高
            (3) 散列表由于要减少冲突，设置了装载因子，在一定程度消耗内存．
            (4) 散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定,平衡二叉查找树的性能非常稳定，
                时间复杂度稳定在 O(logn)
            
            (5) 散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。
                平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。
    10. 二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于 log2 n 的情况，从而导致各个操作的效率下降。
        极端情况下，二叉树会退化为链表，时间复杂度会退化到 O(n)
           
```

## 红黑树(Red-Black Tree)

```shell
    1. 平衡二叉查找树: 二叉树中任意一个节点的左右子树的高度相差不能大于 1
    2. 平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，
       出现时间复杂度退化的问题。
    3. 设计一个新的平衡二叉查找树，只要树的高度不比 log2 n 大很多(比如树的高度仍然是对数量级的)，
       尽管它不符合严格意义平衡二叉查找树的定义，仍然可以说是一个合格的平衡二叉查找树。
    4. 有的时候我们所讲的平衡二叉树就是指红黑树,红黑树简称 R-B Tree,红黑树不是严格意义的平衡二叉树 ,
        红黑树从根到叶子的最长路劲不会超过最短路劲的 2 倍
    5. 红黑树的特点:
            (1) 一类被标记为黑色，一类被标记为红色
            (2) 根节点是黑色的
            (3) 每个叶子节点都是黑色的空节点(NIL)(叶子节点不存储数据),主要是为了简化红黑树的代码实现而设置的
            (4) 任何相邻的节点都不能同时为红色(红色节点是被黑色节点隔开的)
            (5) 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；
    6. 红黑树是近似平衡(性能不会退化的太严重),可以通过一步一步推导，首先现将红黑树的红色节点去掉，则有之前的
    　　二叉树变为四叉树,其四叉树的高度比包含相同节点个数的完全二叉树的高度还要小，完全二叉树的高度近似 log2 n,
       那么去掉红色节点的 "黑树" 高度也不会超过 log2 n, 这时再把红色节点加回去，则根据红色节点不能相邻，
       也就是说，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开。
       红黑树中包含最多黑色节点的路径不会超过 log2 n，加入红色节点后，最长路径不会超过 2 * log2 n，
       那么红黑树的高度近似 2 * log2 n。
    7. 实际项目中在平衡二叉查找树多用红黑树
             (1) Treap、Splay Tree，绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。
                 尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用。
             (2) AVL 树是一种高度平衡的二叉树,AVL 树为了维持这种高度的平衡,每次插入、删除都要做调整，就比较复杂、耗时
                 对于频繁的插入、删除操作的数据集合，使用 AVL 树的代价有点高
             (3) 红黑树只是近似平衡，在维护成本上要比 AVL 树要低，其插入、删除、查找各种操作性能都比较稳定
    8. 红黑树的平衡过程是遇到什么样的节点排布，就对应怎么去调整。只要按照这些固定的调整规则来操作，
    　　就能将一个非平衡的红黑树调整成平衡的。
    9. 插入和删除节点会使红黑树的特点(4), 特点(5) 失效.这个时候得用到左旋和右旋来平衡，左旋：对x进行左旋，意味着
       "将x变成一个左节点" 具体的实现是左右旋转和改变颜色等操作
    10. 插入操作的平衡调整
            (1) 插入的节点必须是红色的并且二叉查找树中新插入的节点都是放在叶子节点上
            (2) 两种特殊的插入情况
                    I. 如果插入节点的父节点是黑色的(即叶子节点的父节点)，那我们什么都不用做，
                    　 它仍然满足红黑树的定义(因为插入新的节点是红色的)
                    II. 如果插入的节点是根节点，那直接改变它的颜色，把它变成黑色就可以了。
            (3) 新节点插入之后，如果红黑树的平衡被打破，那一般会有下面三种情况(每一种情况对应不同的处理方式)
                    CASE 1 :
                             条件：如果关注节点是 a(红)，它的叔叔节点 d 是红色，依次执行下面的操作:
                             第一步: 将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色；
                             第二步: 将关注节点 a 的祖父节点 c 的颜色设置成红色；
                             第三步: 关注节点变成由 a 节点变为其祖父节点 c；
                             第四步: 跳到 CASE 2 或者 CASE 3
                             
                     注解: 其中 x, y, z, p, q 都是其他子树      
                       
                           c(黑)                                               c(红)  
                        /       \                                           /       \
                      b(红)       d(红)                                   b(黑)       d(黑)
                     /　　\　     /   \          -------->               /　　\　     /   \  
                    z     a(红)  p    q                                z     a(红)  p    q
                         /   \                                              /   \
                        x     y                                            x     y     
                        
                        
                    CASE 2:
                            条件：如果关注节点是 a(红)，叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点，
                            　　　依次执行下面的操作：
                                    第一步: 关注节点变成节点 a 的父节点 b；
                                    第二步: 围绕新的关注节点 b 左旋；
                                    第三步: 跳到 CASE 3
                                    
                    注解: 其中 x, y, z, p, q 都是其他子树  
                           c(黑)                                               c(黑)  
                        /       \                                           /       \
                      b(红)       d(黑)                                   a(红)       d(黑)
                     /　　\　     /   \          -------->               /　　\　     /   \  
                    z     a(红)  p    q                                b(红)  y     p    q
                         /   \                                       /   \
                        x     y                                     z     x     
                        
                    
                    CASE 3:
                            条件：如果关注节点是 a(红)，叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点，
                                 依次执行下面的操作：
                                    第一步: 围绕关注节点 a 的祖父节点 c 右旋；
                                    第二步: 将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。
                                    第三步: 调整结束
                    注解: 其中 x, y, z, p, q 都是其他子树  
                    
                              c(黑)                                         b(红)
                           /       \                                      /       \
                        a(红)       d(黑)                                a(红)       c(黑)
                       /　　\　     /   \      -------->                 /　　\　     /   \ 
                     b(红)  y     p    q                               z     x     y    d(黑) 
                    /   \                                                              /   \
                   z     x                                                            p    q
                   
                   
                   --------->                    b(黑)
                                              /       \
                                           a(红)       c(红)
                                          /　　\　     /   \ 
                                         z     x     y    d(黑) 
                                                         /   \
                                                        p    q
                                                        
    11. 删除操作的平衡调整
            (1) 删除操作的平衡调整分为两步:
                第一步是针对删除节点初步调整。初步调整只是保证整棵红黑树在一个节点删除之后，
            　　      仍然满足最后一条定义的要求(每个节点，从该节点到达其可达叶子节点的所有路径，
                     都包含相同数目的黑色节点)
                第二步是针对关注节点进行二次调整，让它满足红黑树的第三条定义(不存在相邻的两个红色节点)
            (2) 针对删除节点初步调整
                    I. 经过初步调整之后，为了保证满足红黑树定义的最后一条要求(个节点，从该节点到达其可达叶子节点的所有路径，
                       都包含相同数目的黑色节点)，有些节点会被标记成两种颜色，“红 - 黑”或者“黑 - 黑”。
                       如果一个节点被标记为了“黑 - 黑”，那在计算黑色节点个数时，要算成两个黑色节点
                    II.
                        CASE 1: 如果要删除的节点是 a，它只有一个子节点 b (不管是左子树还是右子树)
                                依次执行下面的操作：
                                    第一步: 删除节点 a，并且把节点 b 替换到节点 a 的位置
                                    第二步: 节点 a 只能是黑色，节点 b 也只能是红色(其他情况均不符合红黑树的定义)
                                           把节点 b 改为黑色；
                                    第三步: 调整结束，不需要进行二次调整。
                                    
                                      | 
                                    a(黑)                           |
                                        \                         b(黑)
                                          b(红)    ------>        /   \ 
                                         /   \ 
                                         
                        CASE 2: 如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c
                                依次执行下面的操作：
                                    第一步: 如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。
                                           把节点 a 删除，并且将节点 c 替换到节点 a 的位置。
                                    第二步: 然后把节点 c 的颜色设置为跟节点 a 相同的颜色；
                                    第三步: 如果节点 c 是黑色，为了不违反红黑树的最后一条定义(每个节点，
                                           从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点)，
                                           给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了
                                           “红 - 黑”或者“黑 - 黑”；
                                    第四步: 关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做
                                    
                                      |                                              |
                                  a(可红可黑)                                     c(可红可黑)
                                  /       \                                     /       \
                            b(可红可黑)     c(可红可黑)        ------>      b(可红可黑)     d(红 - 黑”或者“黑 - 黑”
                            /      \          \                           /      \      /      \
                                              d(可红可黑)
                                              /   \
                                              
                        CASE 3: 如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是 a 的右子节点
                                依次执行下面的操作：
                                    第一步: 找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 CASE 1；
                                    第二步: 将节点 a 替换成后继节点 d；
                                    第三步: 把节点 d 的颜色设置为跟节点 a 相同的颜色；
                                    第四步: 如果节点 d 是黑色，为了不违反红黑树的最后一条定义(每个节点，从该节点到达其
                                           可达叶子节点的所有路径，都包含相同数目的黑色节点)，给节点 d 的右子节点 c 
                                           多加一个黑色，这个时候节点 c 就成了“红 - 黑”或者“黑 - 黑”；
                                    第五步: 关注节点变成了节点 c，二次调整操作就会针对关注节点来做。
                                    
                                 |                                         |    
                             a(可红可黑)                                 d(可红可黑)
                             /       \                                 /       \    
                     b(可红可黑)     c(可红可黑)    ---->          b(可红可黑)     c(红 - 黑”或者“黑 - 黑)
                     /    \         /                             /    \         /
                                   d                                         e(可红可黑)
                                    \                                        /     \
                                   e(可红可黑)                                 
                                   /     \
                                   
            (3)  针对关注节点进行二次调整
                    I. 经过初步调整后，关注节点变成了“红 - 黑”或者“黑 - 黑”节点。针对这个关注节点，
                       再分四种情况来进行二次调整。二次调整是为了让红黑树中不存在相邻的红色节点。
                    II. CASE 1: 如果关注节点是 a，它的兄弟节点 c 是红色的
                                依次执行下面的操作：
                                    第一步: 围绕关注节点 a 的父节点 b 左旋；
                                    第二步: 关注节点 a 的父节点 b 和祖父节点 c 交换颜色；
                                    第三步: 关注节点不变；
                                    第四步: 继续从四种情况中选择适合的规则来调整。
                     注解: 其中 x, y, z, p, q 都是其他子树 
                                    
                                 b(黑)                                                        c(红)
                               /     \                                                  /            \  
              a(红 - 黑”或者“黑 - 黑)   c(红)              ---->                        b(黑)             e(黑) 
                   /    \             /        \                             /                \         /    \
                 x        y       d(黑)        e(黑)                    a(红 - 黑”或者“黑 - 黑)   d(黑)  p     q
                                /    \        /     \                       /    \             /  \
                               z      w      p       q                     x      y           z   w
                               
                               
                                                                          c(黑)
                             ---->                                    /            \    
                                                                 b(红)             e(黑)
                                                              /       \            /    \
                                                a(红 - 黑”或者“黑 - 黑)   d(黑)     p     q
                                                    /    \             /  \
                                                  x      y            z   w 
                                                  
                        CASE 2: 如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的
                                依次执行下面的操作：
                                    第一步: 将关注节点 a 的兄弟节点 c 的颜色变成红色；
                                    第二步: 从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；
                                    第三步: 给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了
                                           “红 - 黑”或者“黑 - 黑”；
                                    第四步: 关注节点从 a 变成其父节点 b；
                                    第五步: 继续从四种情况中选择符合的规则来调整。
                                    
                                b(可红可黑)                                     b(红 - 黑”或者“黑 - 黑)                  
                               /     \                                              /           \                     
              a(红 - 黑”或者“黑 - 黑)     c(黑)              ---->              a(可红可黑)       c(红)     
                   /    \             /        \                              /    \          /       \   
                 x        y       d(黑)        e(黑)                         x       y       d(黑)      e(黑) 
                                /    \        /     \                                       /    \    /     \  
                               z      w      p       q                                    z      w   p       q
                               
                               
                       CASE 3：　如果关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色，
                       　　　　　 依次执行下面的操作：
                                    第一步: 围绕关注节点 a 的兄弟节点 c 右旋；
                                    第二步: 节点 c 和节点 d 交换颜色；
                                    第三步: 关注节点不变；
                                    第四步: 跳转到 CASE 4，继续调整。
                                    
                                 b(可红可黑)                                        b(可红可黑) 
                               /     \                                          /              \  
              a(红 - 黑”或者“黑 - 黑)   c(黑)              ---->  a(红 - 黑”或者“黑 - 黑)         d(红) 
                   /    \             /       \                  /                \         /    \
                 x        y       d(红)        e(黑)            x                   y      z      c(黑)
                                /    \        /     \                                            /   \
                               z      w      p       q                                         w     e(黑)                                 
                                                                                                      /   \
                                                                                                     p     q
                                                                                                     
                                                                    b(可红可黑) 
                                                               /              \  
                                      ---->    a(红 - 黑”或者“黑 - 黑)         d(黑) 
                                                /                \         /    \
                                               x                   y      z      c(红)
                                                                               /   \
                                                                             w     e(黑)                                 
                                                                                  /   \
                                                                                 p     q     
                                                                                                          
                      　CASE 4: 如果关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的，
                                依次执行下面的操作：
                                     第一步: 围绕关注节点 a 的父节点 b 左旋；
                                     第二步: 将关注节点 a 的祖父节点 c 的颜色，跟关注节点 a 的父节点 b 
                                            设置成相同的颜色；
                                     第三步: 将关注节点 a 的父节点 b 的颜色设置为黑色；
                                     第四步: 从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；
                                     第五步: 将关注节点 a 的叔叔节点 e 设置为黑色；
                                     第六步: 调整结束。
                        b(可黑可红)                                                   c(黑)
                       /     \                                                  /            \  
      a(红 - 黑”或者“黑 - 黑)    c(黑)              ---->                 b(可红可黑)             e(红) 
           /    \             /        \                             /            \       　 /    \
         x        y       d(可黑可红)   e(红)           　a(红 - 黑”或者“黑 - 黑)   d(可红可黑)  p     q
                        /    \        /     \                       /    \         /  \
                       z      w      p       q                     x      y       z   w                                     
 
                                                            c(黑)
                                                        /            \  
     　　　　 　　　        ---->                 b(可红可黑)             e(红) 
          　　　　　                           /            \       　 /    \
       　　　　　　　　         　a(红 - 黑”或者“黑 - 黑)   d(可红可黑)  　p     q
                     　　                 /    \         /  \
      　　　　　　　　　　                  x      y       z   w                                    
                               
```

